package com.bot.BattleRoyale;

import net.dv8tion.jda.core.entities.*;
import net.dv8tion.jda.core.events.message.MessageReceivedEvent;
import org.jetbrains.annotations.NotNull;

import java.util.*;

/**
 * Preform a battle royale based on the data given in the constructor, and weapons and armor generated by the weapon
 * and armor factories.
 * @author Argetlam-Elda
 */
public class BattleRoyale extends Thread {

	/**
	 * The guild where this battle is taking place.
	 */
	private Guild guild;

	/**
	 * The channel where this battle will be printed.
	 */
	private MessageChannel channel;

	private MessageQueue messages;

	/**
	 * A list of all the fighters in this match.
	 */
	private ArrayList<Fighter> fighters;

	/**
	 * A stored random generator, so there are no overlaps in output.
	 */
	private Random rand;

	/**
	 * Tell if this command is to be verbose.
	 */
	private Boolean verbose;

	/**
	 * Tell if this command is to be reduxified.
	 */
	private Boolean redux;

	/**
	 * Init the battle royale. Make a new random generator, set verbose and channel from flags, and generate the fighters.
	 * @param arguments - any arguments passed in with the command
	 * @param event - the message event containing the command to start this battle
	 */
	public BattleRoyale(@NotNull ArrayList<String> arguments, @NotNull MessageReceivedEvent event) throws IllegalStateException {
		fighters = new ArrayList<>();
		rand = new Random();
		verbose = false;
		redux = false;

		arguments.remove(0);

		guild = event.getGuild();
		if (guild == null) {
			throw new IllegalStateException("Can't preform a battle royale from a direct message. Try running this in a server.");
		}

		ArrayList<String> switches = new ArrayList<>();
		for (String argument: arguments) {
			if (argument.startsWith("-")) {
				switches.add(argument.substring(1).toLowerCase());
			}
		}

		fighters = getFighters(event);

		if (switches.contains("r") || switches.contains("redux")) {
			redux = true;
		}

		if (switches.contains("v") || switches.contains("verbose")) {
			verbose = true;
		}

		channel = event.getAuthor().openPrivateChannel().complete();
		List<TextChannel> channels = guild.getTextChannelsByName("fight-pit", true);
		channels.addAll(guild.getTextChannelsByName("battle-royale", true));
		if (!channels.isEmpty()) {
			channel = channels.get(0);
		}
		if (switches.contains("here")) {
			channel = event.getChannel();
		}
		if (switches.contains("dm") || switches.contains("direct-message")) {
			channel = event.getAuthor().openPrivateChannel().complete();
		}

		messages = new MessageQueue(channel);
	}

	/**
	 * Continue to preform rounds until all but one player is dead. Print player hp and attacks every round.
	 */
	@Override
	public void run() {
		if (this.isInterrupted()) {
			return;
		}
		int roundCount = 0;
		// As long as there is more than one fighter, do another round
		while (fighters.size() > 1) {
			roundCount++;
			// Get the max name length
			int nameLength = 0;
			int weaponNameLength = 0;
			int hitFlavorTextLength = 0;
			for (Fighter fighter: fighters) {
				nameLength = Math.max(fighter.toString().length(), nameLength);
				weaponNameLength = Math.max(fighter.getWeapon().toString().length(), weaponNameLength);
				hitFlavorTextLength = Math.max(fighter.getWeapon().getFlavorTextLength(), hitFlavorTextLength);
			}
			int startingCombatants = fighters.size();
			// Do a round of battle
			StringBuilder battleReport = new StringBuilder();
			battleReport.append(enactRound(nameLength, weaponNameLength, hitFlavorTextLength));
			if (battleReport.toString().length() == 0) {
				battleReport.append("No fatalities.\n");
			}
			battleReport.insert(0, "\tRound " + roundCount + ":\tCombatants: " + startingCombatants + "\n");
			try {
				if (!redux) {
					messages.endRound(roundCount, startingCombatants, fighters.size());
					sendBattleReport(battleReport.toString());
					sendHPList(nameLength);
				}
			} catch (InterruptedException e) {
				return;
			}
		}
		if (fighters.size() == 0) {
			channel.sendMessage("```Loser, loser, chicken loser.\n```").queue();
		}
		else if (fighters.size() == 1) {
			messages.endMatch(fighters.get(0), guild.getName());
		}
		else {
			channel.sendMessage("```\nBehold your champions, "  + fighters.toString() + ". Idk what happened, but I guess you all win.\n```").queue();
		}
	}

	/**
	 * Send message(s) containing the health of everyone still in the fight.
	 * @param nameLength - longest name in the list.
	 * @throws InterruptedException - sleep() failed, probably
	 */
	private void sendHPList(int nameLength) throws InterruptedException {
		if (!verbose) {
			return;
		}
		StringBuilder output = new StringBuilder("```\nRemaining Combatants: " + fighters.size() + "\n");
		for (Fighter fighter: fighters) {
			String line = String.format("%-" + nameLength + "s: %-2d\n", fighter.toString(), fighter.getHealth());
			messages.addHp(line);
//			if (output.length() + line.length() < 1900) {
//				output.append(line);
//			}
//			else {
//				output.append("```");
				// channel.sendMessage(output).complete();
//				sleep(1000);
//				output = new StringBuilder("```\n" + line);
//			}
		}
//		output.append("```");
		// channel.sendMessage(output).queue();
//		sleep(1000);
	}

	/**
	 * Send message(s) containing the battle data from each round of combat.
	 * @param battleReport - string to print
	 * @throws InterruptedException - sleep() failed, probably
	 */
	private void sendBattleReport(String battleReport) throws InterruptedException {
		StringBuilder output = new StringBuilder("```\n");
		Scanner reportScanner = new Scanner(battleReport);
		while (reportScanner.hasNext()) {
			String line = reportScanner.nextLine();
			if (output.length() + line.length() < 1900) {
				output.append(line);
				output.append("\n");
			}
			else {
				output.append("```");
				channel.sendMessage(output).queue();
				sleep(1000);
				output = new StringBuilder("```\n" + line + "\n");
			}
		}
		output.append("```");
		channel.sendMessage(output).queue();
		sleep(1000);

	}

	/**
	 * Preform all actions needed for the attacker to assault the defender.
	 * @param attacker - fighter preforming the attack
	 * @param defender - fighter being attacked
	 * @param nameLength - the max name length in this round
	 * @return - A string containing the log data for this attack
	 */
	private String enactAttack(@NotNull Fighter attacker, Fighter defender, int nameLength, int weaponNameLength, int hitFlavorTextLength) {
		// Target of the attack, will be defender unless there is a critical fail
		Fighter target = defender;
		// Roll to hit
		int roll = rand.nextInt(20) + 1;
		// Damage total
		int damage = rand.nextInt(10) + roll + 1 + attacker.getWeapon().getDamage();
		// Critical fail, hit self
		if (roll == 1) {
			target = attacker;
		}
		else if (roll == 20) {
			damage += 10;
		}
		// If there is no target (only if attacker is the last combatant and didn't hit themself)
		if (target == null) {
			return "";
		}
		// Target takes damage, and return the damage they take after armor resistance.
		damage = target.takeDamage(damage);
		String hitFlavorText;
		StringBuilder battleReport = new StringBuilder();
		// on a critical hit
		if (roll == 20) {
			hitFlavorText = attacker.getWeapon().getFlavor(WeaponFactory.WeaponFlavor.CRIT);
			battleReport.append("  Critical hit!\n");
			if (attacker.getWeapon().cripple(defender.getArmor(), rand)) {
				battleReport.append(attacker.toString());
				battleReport.append(" destroyed ");
				battleReport.append(defender.toString());
				battleReport.append( "'s ");
				battleReport.append(defender.getArmor().toString());
				battleReport.append(" with their ");
				battleReport.append(attacker.getWeapon());
				battleReport.append(".\n");
			}
		}
		// on a critical fail
		else if (roll == 1) {
			battleReport.append("  Critical fail!\n");
			if (target.getHealth() <= 0) {
				hitFlavorText = attacker.getWeapon().getFlavor(WeaponFactory.WeaponFlavor.SUICIDE);
			}
			else {
				hitFlavorText = attacker.getWeapon().getFlavor(WeaponFactory.WeaponFlavor.SELF);
				if (fighters.size() == 1) {
					battleReport.append(attacker);
					battleReport.append(", seeing no more opponents before them, attempts to end it all, but fails. Not that we expected anything more from them.");
				}
			}
		}
		// on a regular hit
		else {
			hitFlavorText = attacker.getWeapon().getFlavor(WeaponFactory.WeaponFlavor.HIT);
			battleReport.append("\n");
		}
		// Store the default format attack
		String format = "%-" + nameLength + "s %-" + hitFlavorTextLength + "s %-" + nameLength + "s with their %-" + weaponNameLength + "s for %" + "2" + "d";
		battleReport.insert(0, String.format(format, attacker, hitFlavorText, (target == attacker ? "themself" : target), attacker.getWeapon(), damage));
		if (!verbose) {
			battleReport = new StringBuilder();
		}
		if (target.getHealth() <= 0) {
			if (attacker == target) {
				if (fighters.size() == 1) {
					battleReport.append(attacker);
					battleReport.append(", seeing no more opponents before them, decides to end it all.");
				} else {
					battleReport.append(attacker);
					battleReport.append(" kills themself out of shame.");
				}
			} else {
				if (roll == 20) {
					battleReport.append(attacker);
					battleReport.append(" fucking murders ");
					battleReport.append(defender);
					battleReport.append(" with their ");
					battleReport.append(attacker.getWeapon());
				}
				else {
					battleReport.append(attacker);
					battleReport.append(" kills ");
					battleReport.append(defender);
					battleReport.append(" with their ");
					battleReport.append(attacker.getWeapon());
				}
				battleReport.append(attacker.lootFigher(defender, rand));
				battleReport.append("!\n");
			}
			fighters.remove(target);
		}
		messages.addAttack(battleReport.toString());
		return battleReport.toString();
	}

	/**
	 * Preform all actions needed for the round
	 * @param nameLength - the max name length in this round
	 * @return - A string containing the log data for attacks in this round
	 */
	private String enactRound(int nameLength, int weaponNameLength, int hitFlavorTextLength) {
		// Textual record of what happens during each round
		StringBuilder battleReport = new StringBuilder();
		// Shuffle the fighter attack order
		@SuppressWarnings("unchecked")
		ArrayList<Fighter> shuffledFighters = (ArrayList<Fighter>) fighters.clone();
		Collections.shuffle(shuffledFighters);
		for (Fighter attacker: shuffledFighters) {
			Fighter defender = null;
			// if there is a potential for revenge, 50% chance of attacking them
			if (attacker.getRevengeTarget() != null && shuffledFighters.contains(attacker.getRevengeTarget()) && rand.nextBoolean()) {
				defender = attacker.getRevengeTarget();
			}
			else if (fighters.size() != 1) {
				while(defender == null || defender == attacker) {
					defender = fighters.get(rand.nextInt(fighters.size()));
				}
			}
			battleReport.append(enactAttack(attacker, defender, nameLength, weaponNameLength, hitFlavorTextLength));
		}
		return battleReport.toString();
	}

	/**
	 * Build a list of fighters from the switches passed in and the members of the guild.
	 * @param event - the message event containing the command to start this battle
	 * @return - an alphabetically sorted list of the fighters
	 */
	private ArrayList<Fighter> getFighters(MessageReceivedEvent event) {
		ArrayList<Member> candidates;
		// Play with mentioned people
		if (!event.getMessage().getMentionedMembers().isEmpty()) {
			candidates = new ArrayList<>(event.getMessage().getMentionedMembers());
		}
		// Play with players that have the mentioned rolls
		else if (!event.getMessage().getMentionedRoles().isEmpty()) {
			candidates = new ArrayList<>(event.getGuild().getMembersWithRoles(event.getMessage().getMentionedRoles()));
		}
		else {
			candidates = new ArrayList<>(event.getGuild().getMembers());
		}
		// remove bots
		for (int i = 0; i < candidates.size(); i++) {
			if (candidates.get(i).getUser().isBot()) {
				candidates.remove(i);
				i--;
			}
		}
		if (candidates.size() < 3) {
			channel.sendMessage(":x:You need least 3 contestants to hold a battle royale.:x:").queue();
			interrupt();
		}
		for (Member candidate: candidates) {
			fighters.add(new Fighter(candidate));
		}
		if (fighters.size() == 0) {
			interrupt();
		}
		Collections.sort(fighters);
		 return fighters;
	}
}
