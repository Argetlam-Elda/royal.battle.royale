package com.bot.BattleRoyale;

import net.dv8tion.jda.core.entities.*;
import net.dv8tion.jda.core.events.message.MessageReceivedEvent;

import java.util.*;

/**
 * Preform a battle royale based on the data given in the constructor, and weapons and armor generated by the weapon
 * and armor factories.
 *
 * @author Argetlam-Elda
 */
public class BattleRoyale extends Thread {
	
	/**
	 * The guild where this battle is taking place.
	 */
	private Guild guild;
	
	/**
	 * The channel where this battle will be printed.
	 */
	private MessageChannel channel;
	
	private MessageQueue messages;
	
	/**
	 * A list of all the fighters in this match.
	 */
	private ArrayList<Fighter> fighters;
	
	/**
	 * A stored random generator, so there are no overlaps in output.
	 */
	private Random rand;
	
	/**
	 * Init the battle royale. Make a new random generator, set verbose and channel from flags, and generate the fighters.
	 *
	 * @param arguments - any arguments passed in with the command
	 * @param event     - the message event containing the command to start this battle
	 */
	public BattleRoyale(ArrayList<String> arguments, MessageReceivedEvent event) throws IllegalStateException {
		fighters = new ArrayList<>();
		rand = new Random();
		boolean verbose = false;
		boolean redux = false;
		
		arguments.remove(0);
		
		guild = event.getGuild();
		if (guild == null) {
			throw new IllegalStateException("Can't preform a battle royale from a direct message. Try running this in a server.");
		}
		
		ArrayList<String> switches = new ArrayList<>();
		for (String argument : arguments) {
			if (argument.startsWith("-")) {
				switches.add(argument.substring(1).toLowerCase());
			}
		}
		
		fighters = Fighter.getFighters(event);
		
		if (switches.contains("r") || switches.contains("redux")) {
			redux = true;
		}
		
		if (switches.contains("v") || switches.contains("verbose")) {
			verbose = true;
		}
		
		channel = event.getAuthor().openPrivateChannel().complete();
		List<TextChannel> channels = guild.getTextChannelsByName("fight-pit", true);
		channels.addAll(guild.getTextChannelsByName("battle-royale", true));
		if (!channels.isEmpty()) {
			channel = channels.get(0);
		}
		if (switches.contains("here")) {
			channel = event.getChannel();
		}
		if (switches.contains("dm") || switches.contains("direct-message")) {
			channel = event.getAuthor().openPrivateChannel().complete();
		}
		
		messages = new MessageQueue(channel, verbose, redux);
	}
	
	/**
	 * Continue to preform rounds until all but one player is dead. Print player hp and attacks every round.
	 */
	@Override
	public void run() {
		if (this.isInterrupted()) {
			return;
		}
		// As long as there is more than one fighter, do another round
		for (int roundCount = 1; fighters.size() > 1; roundCount++) {
			// Do a round of battle
			enactRound(roundCount);
		}
		messages.endMatch(fighters, guild.getName());
	}
	
	/**
	 * Send message(s) containing the battle data from each round of combat.
	 *
	 * @param battleReport - string to print
	 * @throws InterruptedException - sleep() failed, probably
	 */
	private void sendBattleReport(String battleReport) throws InterruptedException {
		StringBuilder output = new StringBuilder("```\n");
		Scanner reportScanner = new Scanner(battleReport);
		while (reportScanner.hasNext()) {
			String line = reportScanner.nextLine();
			if (output.length() + line.length() < 1900) {
				output.append(line);
				output.append("\n");
			} else {
				output.append("```");
				channel.sendMessage(output).queue();
				output = new StringBuilder("```\n" + line + "\n");
			}
		}
		output.append("```");
		channel.sendMessage(output).queue();
		
	}
	
	/**
	 * Preform all actions needed for the attacker to assault the defender.
	 *
	 * @param attacker - fighter preforming the attack
	 * @param defender - fighter being attacke
	 */
	private void enactAttack(Fighter attacker, Fighter defender, int roundCount) {
		// Target of the attack, will be defender unless there is a critical fail
		Fighter target = defender;
		// Roll to hit
		int roll = rand.nextInt(20) + 1;
		// Damage total
		int damage = rand.nextInt(10) + roll + 1 + attacker.getWeapon().getDamage();
		// Critical fail, hit self
		if (roll == 1) {
			target = attacker;
		} else if (roll == 20) {
			damage += 10;
		}
		// If there is no target (only if attacker is the last combatant and didn't hit themself)
		if (target == null) {
			return;
		}
		// Target takes damage, and return the damage they take after armor resistance.
		damage = target.takeDamage(damage);
		if (target.isDead()) {
			fighters.remove(target);
		}
		messages.queueAttackMessage(roundCount, attacker, target, damage, roll == 20, roll == 1, (roll == 20 ? attacker.getWeapon().cripple(defender.getArmor(), rand) : false), fighters.size() == 0, attacker.lootFigher(target, rand));
	}
	
	/**
	 * Preform all actions needed for the round
	 */
	private void enactRound(int roundCount) {
		int startingCombatants = fighters.size();
		// Shuffle the fighter attack order
		@SuppressWarnings("unchecked")
		ArrayList<Fighter> shuffledFighters = (ArrayList<Fighter>) fighters.clone();
		Collections.shuffle(shuffledFighters);
		for (Fighter attacker : shuffledFighters) {
			if (attacker.isDead()) {
				continue;
			}
			Fighter defender = null;
			// if there is a potential for revenge, 50% chance of attacking them
			if (attacker.getRevengeTarget() != null && shuffledFighters.contains(attacker.getRevengeTarget()) && rand.nextBoolean()) {
				defender = attacker.getRevengeTarget();
			} else if (fighters.size() != 1) {
				while (defender == null || defender == attacker || defender.isDead()) {
					defender = fighters.get(rand.nextInt(fighters.size()));
				}
			}
			enactAttack(attacker, defender, roundCount);
		}
		messages.endRound(roundCount, startingCombatants, fighters);
	}
	
}
