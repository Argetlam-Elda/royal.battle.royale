package com.bot.BattleRoyale;

import net.dv8tion.jda.core.entities.Guild;
import net.dv8tion.jda.core.entities.MessageChannel;
import net.dv8tion.jda.core.entities.Member;
import net.dv8tion.jda.core.events.message.MessageReceivedEvent;
import org.jetbrains.annotations.NotNull;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Random;
import java.util.Scanner;

/**
 * Preform a battle royale based on the data given in the constructor, and weapons and armor generated by the weapon
 * and armor factories.
 * @author Argetlam-Elda
 */
public class BattleRoyale extends Thread {

	/**
	 * The guild where this battle is taking place.
	 */
	private Guild guild;

	/**
	 * The channel where this battle will be printed.
	 */
	private MessageChannel channel;

	/**
	 * A list of all the fighters in this match.
	 */
	private ArrayList<Fighter> fighters;

	/**
	 * A stored random variable for seeding fights
	 * TODO - maybe remove, since fights will almost never have the same amount of people
	 */
	private Random rand;

	/**
	 * Tell if this command is to be verbose.
	 */
	private Boolean verbose;

	/**
	 * Init the battle royale. Make a new random generator, set verbose and channel from flags, and generate the fighters.
	 * @param arguments - any arguments passed in with the command
	 * @param event
	 */
	public BattleRoyale(@NotNull ArrayList<String> arguments, @NotNull MessageReceivedEvent event) {
		rand = new Random();
		verbose = true;
		guild = event.getGuild();
		channel = event.getChannel();
		fighters = new ArrayList<>();
		fighters = getFighters(arguments, event);
	}

	/**
	 * Continue to preform rounds until all but one player is dead. Print player hp and attacks every round.
	 */
	@Override
	public void run() {
		if (this.isInterrupted()) {
			return;
		}
		// arrange the fighters alphabetically
		Collections.sort(fighters);

		int roundCount = 0;
		// As long as there is more than one fighter, do another round
		while (fighters.size() > 1) {
			roundCount++;
			// Get the max name length
			int nameLength = 0;
			for (Fighter fighter: fighters) {
				nameLength = Math.max(fighter.toString().length(), nameLength);
			}
			int startingCombatants = fighters.size();
			// Do a round of battle
			String battleReport = "\tRound " + roundCount + ":\tCombatants: " + startingCombatants + "\n";
			battleReport += enactRound(nameLength);
			try {
				sendBattleReport(battleReport);
				sendHPList(nameLength);
			} catch (InterruptedException e) {
				return;
			}
		}
		if (fighters.size() == 0) {
			channel.sendMessage("```Loser, loser, chicken loser.\n```").queue();
		}
		else if (fighters.size() == 1) {
			Fighter victor = fighters.get(0);
			channel.sendMessage("```\nBehold your champion, " + victor + " of " + guild.getName() + ", wielding their mighty " + victor.getWeapon() + " and wearing their " + victor.getArmor() +  "!\n```").queue();
		}
		else {
			// TODO - check this never happens
		}
	}

	/**
	 * Send message(s) containing the health of everyone still in the fight.
	 * @param nameLength - longest name in the list.
	 * @throws InterruptedException - sleep() failed, probably
	 */
	private void sendHPList(int nameLength) throws InterruptedException {
		if (!verbose) {
			return;
		}
		String output = "```\nRemaining Combatants: " + fighters.size() + "\n";
		for (Fighter fighter: fighters) {
			String line = String.format("%-" + nameLength + "s: %-2d\n", fighter.toString(), fighter.getHealth());
			if (output.length() + line.length() < 1900) {
				output += line;
			}
			else {
				output += "```";
				channel.sendMessage(output).queue();
				sleep(1000);
				output = "```\n" + line;
			}
		}
		output += "```";
		channel.sendMessage(output).queue();
		sleep(1000);
	}

	/**
	 * Send message(s) containing the battle data from each round of combat.
	 * @param battleReport - string to print
	 * @throws InterruptedException - sleep() failed, probably
	 */
	private void sendBattleReport(String battleReport) throws InterruptedException {
		String output = "```\n";
		Scanner reportScanner = new Scanner(battleReport);
		if (!reportScanner.hasNext()) {
			// if there is no battle report
			output += "No fatalities.\n";
		}
		while (reportScanner.hasNext()) {
			String line = reportScanner.nextLine();
			if (output.length() + line.length() < 1900) {
				output += line + "\n";
			}
			else {
				output += "```";
				channel.sendMessage(output).queue();
				sleep(1000);
				output = "```\n" + line + "\n";
			}
		}
		output += "```";
		channel.sendMessage(output).queue();
		sleep(1000);

	}

	/**
	 * Preform all actions needed for the attacker to assault the defender.
	 * @param attacker - fighter preforming the attack
	 * @param defender - fighter being attacked
	 * @param nameLength - the max name length in this round
	 * @return - A string containing the log data for this attack
	 */
	private String enactAttack(@NotNull Fighter attacker, Fighter defender, int nameLength) {
		// TODO - go through and put weapon and armor back in
		// Target of the attack, will be defender unless there is a critical fail
		Fighter target = defender;
		// Was this hit critical? 2/3 conditions is is
		Boolean critical = true;
		// Roll to hit
		int roll = rand.nextInt(20) + 1;
		// Damage total
		int damage = rand.nextInt(10) + roll + 1 + attacker.getWeapon().getDamage();
		// Critical fail, hit self
		if (roll == 1) {
			target = attacker;
			// damage -= target.getArmor().getResist();
		}
		else if (roll == 20) {
			damage += 10;
		}
		else {
			critical = false;
		}
		// If there is no target (only if attacker is the last combatant and didn't hit themself
		if (target == null) {
			return "";
		}
		// Target takes damage
		target.takeDamage(Math.max(damage, 0));
		String desctructionText = "";
		String hitFlavorText;
		if (roll == 1) {
			if (target.getHealth() < 1) {
				hitFlavorText = attacker.getWeapon().getFlavor(WeaponFactory.WeaponFlavor.SUICIDE);
			}
			else {
				hitFlavorText = attacker.getWeapon().getFlavor(WeaponFactory.WeaponFlavor.SELF);
			}
		}
		else if (roll == 20) {
			hitFlavorText = attacker.getWeapon().getFlavor(WeaponFactory.WeaponFlavor.CRIT);
			// if (attacker.getWeapon().cripple(defender.getArmor(), rand)) {
				// desctructionText = attacker.toString() + " destroyed " + defender.toString() + "'s " + defender.getArmor().toString() + " with their " + attacker.getWeapon() + ".";
			// }
		}
		else {
			hitFlavorText = attacker.getWeapon().getFlavor(WeaponFactory.WeaponFlavor.HIT);
		}
		String battleReport = "";
		if (verbose) {
			// Print the default format attack
			battleReport += String.format("\n%-" + nameLength + "s %-" + "10" + "s %-" + nameLength + "s with their %-" + "1" + "s for %2d", attacker, hitFlavorText, (target == attacker ? "themself" : target), attacker.getWeapon(), damage);
			if (roll == 20 && target == defender) {
				battleReport += "\nCritical hit! " + desctructionText;
			}
			else if (roll == 1) {
				battleReport += "\nCritical fail! ";
				if (target.getHealth() > 0 && fighters.size() == 1) {
					battleReport += "\n" + attacker + ", seeing no more opponents before them, attempts to end it all, but fails. Not that we expected anything more from them.";
				}
			}
			if (target.getHealth() < 1) {
				battleReport += "\n";
			}
		}
		// TODO - loot weapon and or armor
		if (target.getHealth() < 1) {
			if (attacker == target) {
				if (fighters.size() == 1) {
					battleReport += "\n" + attacker + ", seeing no more opponents before them, decides to end it all.";
				} else {
					battleReport += attacker + " kills themself out of shame.";
				}
			} else if (roll == 20) {
				battleReport += attacker + " fucking murders " + defender + " with their " + attacker.getWeapon();
				// TODO - add weapon and armor looting printout
				if (false) {

				} else {
					battleReport += "!";
				}
			} else {
				battleReport += attacker + " kills " + defender + " with their " + attacker.getWeapon();
				if (false) {

				} else {
					battleReport += "!";
				}
			}

			fighters.remove(target);
		}
		return battleReport + (battleReport.length() == 0 ? "" : "\n");
	}

	/**
	 * Preform all acitons needed for the round
	 * @param nameLength - the max name length in this round
	 * @return - A string containing the log data for attacks in this round
	 */
	private String enactRound(int nameLength) {
		// Textual record of what happens during each round
		String battleReport = new String();
		// Shuffle the fighter attack order
		ArrayList<Fighter> shuffledFighters = (ArrayList<Fighter>) fighters.clone();
		Collections.shuffle(shuffledFighters);
		for (Fighter attacker: shuffledFighters) {
			Fighter defender = null;
			// if there is a potential for revenge, 50% chance of attacking them
			if (attacker.getRevengeTarget() != null && shuffledFighters.contains(attacker.getRevengeTarget()) && rand.nextBoolean()) {
				defender = attacker.getRevengeTarget();
			}
			else if (fighters.size() == 1) {
				// TODO - make enactAttack()
				// battleReport += enactAttack();
			}
			else {
				while(defender == null || defender == attacker) {
					defender = fighters.get(rand.nextInt(fighters.size()));
				}
			}
			battleReport += enactAttack(attacker, defender, nameLength);
		}
		return battleReport;
	}

	/**
	 * Build a list of fighters from the switches passed in and the members of the guild.
	 * @param arguments - list of the flags
	 * @param event
	 * @return
	 */
	private ArrayList<Fighter> getFighters(@NotNull ArrayList<String> arguments, MessageReceivedEvent event) {
		ArrayList<Member> candidates;
		// Play with everyone
		if (arguments.isEmpty()) {
			candidates = new ArrayList<>(event.getGuild().getMembers());
		}
		// Play with mentioned people
		else if (event.getMessage().getMentionedMembers().size() > 0) {
			candidates = new ArrayList<>(event.getMessage().getMentionedMembers());
		}
		// Play with players that have the mentioned rolls
		// TODO -
		else {
			candidates = new ArrayList<>(event.getGuild().getMembersWithRoles(event.getMessage().getMentionedRoles()));
		}
		// remove bots
		ArrayList<Member> botlessCandidates = (ArrayList<Member>) candidates.clone();
		for (Member candidate: candidates) {
			if (candidate.getUser().isBot()) {
				botlessCandidates.remove(candidate);
			}
		}
		if (botlessCandidates.size() < 3) {
			channel.sendMessage(":x:You need least 3 contestants to hold a battle royale.:x:").queue();
			interrupt();
		}
		for (Member candidate: botlessCandidates) {
			fighters.add(new Fighter(candidate));
		}
		if (fighters.size() == 0) {
			interrupt();
		}
		 return fighters;
	}
}
